// node_modules/vue3-touch-events/index.js
function touchX(event) {
  if (event.type.indexOf("mouse") !== -1) {
    return event.clientX;
  }
  return event.touches[0].clientX;
}
function touchY(event) {
  if (event.type.indexOf("mouse") !== -1) {
    return event.clientY;
  }
  return event.touches[0].clientY;
}
var isPassiveSupported = function() {
  var supportsPassive = false;
  try {
    var opts = Object.defineProperty({}, "passive", {
      get: function() {
        supportsPassive = true;
      }
    });
    window.addEventListener("test", null, opts);
  } catch (e) {
  }
  return supportsPassive;
}();
var vueTouchEvents = {
  install: function(app, constructorOptions) {
    var globalOptions = Object.assign({}, {
      disableClick: false,
      tapTolerance: 10,
      swipeTolerance: 30,
      touchHoldTolerance: 400,
      longTapTimeInterval: 400,
      touchClass: "",
      dragFrequency: 100,
      rollOverFrequency: 100
    }, constructorOptions);
    function touchStartEvent(event) {
      var $this = this.$$touchObj, isTouchEvent = event.type.indexOf("touch") >= 0, isMouseEvent = event.type.indexOf("mouse") >= 0, $el = this;
      if (isTouchEvent) {
        $this.lastTouchStartTime = event.timeStamp;
      }
      if (isMouseEvent && $this.lastTouchStartTime && event.timeStamp - $this.lastTouchStartTime < 350) {
        return;
      }
      if ($this.touchStarted) {
        return;
      }
      addTouchClass(this);
      $this.touchStarted = true;
      $this.touchMoved = false;
      $this.swipeOutBounded = false;
      $this.startX = touchX(event);
      $this.startY = touchY(event);
      $this.currentX = 0;
      $this.currentY = 0;
      $this.touchStartTime = event.timeStamp;
      $this.hasSwipe = hasEvent(this, "swipe") || hasEvent(this, "swipe.left") || hasEvent(this, "swipe.right") || hasEvent(this, "swipe.top") || hasEvent(this, "swipe.bottom");
      if (hasEvent(this, "hold")) {
        $this.touchHoldTimer = setTimeout(function() {
          $this.touchHoldTimer = null;
          triggerEvent(event, $el, "hold");
        }, $this.options.touchHoldTolerance);
      }
      triggerEvent(event, this, "press");
    }
    function touchMoveEvent(event) {
      var $this = this.$$touchObj;
      var curX = touchX(event);
      var curY = touchY(event);
      var movedAgain = $this.currentX != curX || $this.currentY != curY;
      $this.currentX = curX;
      $this.currentY = curY;
      if (!$this.touchMoved) {
        var tapTolerance = $this.options.tapTolerance;
        $this.touchMoved = Math.abs($this.startX - $this.currentX) > tapTolerance || Math.abs($this.startY - $this.currentY) > tapTolerance;
        if ($this.touchMoved) {
          cancelTouchHoldTimer($this);
          triggerEvent(event, this, "drag.once");
        }
      } else if ($this.hasSwipe && !$this.swipeOutBounded) {
        var swipeOutBounded = $this.options.swipeTolerance;
        $this.swipeOutBounded = Math.abs($this.startX - $this.currentX) > swipeOutBounded && Math.abs($this.startY - $this.currentY) > swipeOutBounded;
      }
      if (hasEvent(this, "rollover") && movedAgain) {
        var now = event.timeStamp;
        var throttle = $this.options.rollOverFrequency;
        if ($this.touchRollTime == null || now > $this.touchRollTime + throttle) {
          $this.touchRollTime = now;
          triggerEvent(event, this, "rollover");
        }
      }
      if (hasEvent(this, "drag") && $this.touchStarted && $this.touchMoved && movedAgain) {
        var now = event.timeStamp;
        var throttle = $this.options.dragFrequency;
        if ($this.touchDragTime == null || now > $this.touchDragTime + throttle) {
          $this.touchDragTime = now;
          triggerEvent(event, this, "drag");
        }
      }
    }
    function touchCancelEvent() {
      var $this = this.$$touchObj;
      cancelTouchHoldTimer($this);
      removeTouchClass(this);
      $this.touchStarted = $this.touchMoved = false;
      $this.startX = $this.startY = 0;
    }
    function touchEndEvent(event) {
      var $this = this.$$touchObj, isTouchEvent = event.type.indexOf("touch") >= 0, isMouseEvent = event.type.indexOf("mouse") >= 0;
      if (isTouchEvent) {
        $this.lastTouchEndTime = event.timeStamp;
      }
      var touchholdEnd = isTouchEvent && !$this.touchHoldTimer;
      cancelTouchHoldTimer($this);
      $this.touchStarted = false;
      removeTouchClass(this);
      if (isMouseEvent && $this.lastTouchEndTime && event.timeStamp - $this.lastTouchEndTime < 350) {
        return;
      }
      triggerEvent(event, this, "release");
      if (!$this.touchMoved) {
        if (hasEvent(this, "longtap") && event.timeStamp - $this.touchStartTime > $this.options.longTapTimeInterval) {
          if (event.cancelable) {
            event.preventDefault();
          }
          triggerEvent(event, this, "longtap");
        } else if (hasEvent(this, "hold") && touchholdEnd) {
          if (event.cancelable) {
            event.preventDefault();
          }
          return;
        } else {
          triggerEvent(event, this, "tap");
        }
      } else if ($this.hasSwipe && !$this.swipeOutBounded) {
        var swipeOutBounded = $this.options.swipeTolerance, direction, distanceY = Math.abs($this.startY - $this.currentY), distanceX = Math.abs($this.startX - $this.currentX);
        if (distanceY > swipeOutBounded || distanceX > swipeOutBounded) {
          if (distanceY > swipeOutBounded) {
            direction = $this.startY > $this.currentY ? "top" : "bottom";
          } else {
            direction = $this.startX > $this.currentX ? "left" : "right";
          }
          if (hasEvent(this, "swipe." + direction)) {
            triggerEvent(event, this, "swipe." + direction, direction);
          } else {
            triggerEvent(event, this, "swipe", direction);
          }
        }
      }
    }
    function mouseEnterEvent() {
      addTouchClass(this);
    }
    function mouseLeaveEvent() {
      removeTouchClass(this);
    }
    function hasEvent($el, eventType) {
      var callbacks = $el.$$touchObj.callbacks[eventType];
      return callbacks != null && callbacks.length > 0;
    }
    function triggerEvent(e, $el, eventType, param) {
      var $this = $el.$$touchObj;
      var callbacks = $this.callbacks[eventType];
      if (callbacks == null || callbacks.length === 0) {
        return null;
      }
      for (var i = 0; i < callbacks.length; i++) {
        var binding = callbacks[i];
        if (binding.modifiers.stop) {
          e.stopPropagation();
        }
        if (binding.modifiers.prevent) {
          e.preventDefault();
        }
        if (binding.modifiers.self && e.target !== e.currentTarget) {
          continue;
        }
        if (typeof binding.value === "function") {
          if (param) {
            binding.value(param, e);
          } else {
            binding.value(e);
          }
        }
      }
    }
    function addTouchClass($el) {
      var className = $el.$$touchObj.options.touchClass;
      className && $el.classList.add(className);
    }
    function removeTouchClass($el) {
      var className = $el.$$touchObj.options.touchClass;
      className && $el.classList.remove(className);
    }
    function cancelTouchHoldTimer($this) {
      if ($this.touchHoldTimer) {
        clearTimeout($this.touchHoldTimer);
        $this.touchHoldTimer = null;
      }
    }
    function buildTouchObj($el, extraOptions) {
      var touchObj = $el.$$touchObj || {
        callbacks: {},
        hasBindTouchEvents: false,
        options: globalOptions
      };
      if (extraOptions) {
        touchObj.options = Object.assign({}, touchObj.options, extraOptions);
      }
      $el.$$touchObj = touchObj;
      return $el.$$touchObj;
    }
    app.directive("touch", {
      beforeMount: function($el, binding) {
        var $this = buildTouchObj($el);
        var passiveOpt = isPassiveSupported ? { passive: true } : false;
        var eventType = binding.arg || "tap";
        switch (eventType) {
          case "swipe":
            var _m = binding.modifiers;
            if (_m.left || _m.right || _m.top || _m.bottom) {
              for (var i in binding.modifiers) {
                if (["left", "right", "top", "bottom"].indexOf(i) >= 0) {
                  var _e = "swipe." + i;
                  $this.callbacks[_e] = $this.callbacks[_e] || [];
                  $this.callbacks[_e].push(binding);
                }
              }
            } else {
              $this.callbacks.swipe = $this.callbacks.swipe || [];
              $this.callbacks.swipe.push(binding);
            }
            break;
          case "press":
          case "drag":
            if (binding.modifiers.disablePassive) {
              passiveOpt = false;
            }
          default:
            $this.callbacks[eventType] = $this.callbacks[eventType] || [];
            $this.callbacks[eventType].push(binding);
        }
        if ($this.hasBindTouchEvents) {
          return;
        }
        $el.addEventListener("touchstart", touchStartEvent, passiveOpt);
        $el.addEventListener("touchmove", touchMoveEvent, passiveOpt);
        $el.addEventListener("touchcancel", touchCancelEvent);
        $el.addEventListener("touchend", touchEndEvent);
        if (!$this.options.disableClick) {
          $el.addEventListener("mousedown", touchStartEvent);
          $el.addEventListener("mousemove", touchMoveEvent);
          $el.addEventListener("mouseup", touchEndEvent);
          $el.addEventListener("mouseenter", mouseEnterEvent);
          $el.addEventListener("mouseleave", mouseLeaveEvent);
        }
        $this.hasBindTouchEvents = true;
      },
      unmounted: function($el) {
        $el.removeEventListener("touchstart", touchStartEvent);
        $el.removeEventListener("touchmove", touchMoveEvent);
        $el.removeEventListener("touchcancel", touchCancelEvent);
        $el.removeEventListener("touchend", touchEndEvent);
        if ($el.$$touchObj && !$el.$$touchObj.options.disableClick) {
          $el.removeEventListener("mousedown", touchStartEvent);
          $el.removeEventListener("mousemove", touchMoveEvent);
          $el.removeEventListener("mouseup", touchEndEvent);
          $el.removeEventListener("mouseenter", mouseEnterEvent);
          $el.removeEventListener("mouseleave", mouseLeaveEvent);
        }
        delete $el.$$touchObj;
      }
    });
    app.directive("touch-class", {
      beforeMount: function($el, binding) {
        buildTouchObj($el, {
          touchClass: binding.value
        });
      }
    });
    app.directive("touch-options", {
      beforeMount: function($el, binding) {
        buildTouchObj($el, binding.value);
      }
    });
  }
};
var vue3_touch_events_default = vueTouchEvents;
export {
  vue3_touch_events_default as default
};
//# sourceMappingURL=vue3-touch-events.js.map
